//ğŸ¥¸
#include <iostream>
#include <vector>
#include <cstring>//åŒ…å«memsetå‡½æ•°
using namespace std;

const int N = 201; // æœ€å¤§èŠ‚ç‚¹æ•°
int n, m;
vector<int> G[N]; 
int cap[2*N][2*N]; 
int flow[2*N][2*N]; 
int s, t; 
bool left_used[N]; 
bool right_used[N]; //ç”¨äºæœ€åæ‰¾åˆ°è·¯å¾„
bool visited[2*N];
int pre[2*N];

bool dfs(int u) {// æ·±åº¦ä¼˜å…ˆæœç´¢ç”¨äºå¯»æ‰¾å¢å¹¿è·¯å¾„
    if (u == t) return true;
    visited[u] = true;  
    for (int v = 0; v < 2*n+2; v++) {
        if (!visited[v] && (cap[u][v] > flow[u][v])) {
            pre[v] = u;
            if (dfs(v)) return true;
        }
    }
    return false;
}

int maxFlow() {// Ford-Fulkersonç®—æ³•æ±‚æœ€å¤§æµ
    int maxflow = 0;
    while (true) {
        memset(visited, 0, sizeof(visited));//è®°å¾—æ¸…ç©ºvisitedæ•°ç»„
        memset(pre, -1, sizeof(pre));
        if (!dfs(s)) break;
        
        int f = 999999;
        for (int i = t; i != s; i = pre[i]) { //æ‰¾åˆ°æœ€å°å‰©ä½™å®¹é‡f
            int u = pre[i];
            f = min(f, cap[u][i] - flow[u][i]);
        }        
        for (int i = t; i != s; i = pre[i]) { // æ›´æ–°æµé‡
            int u = pre[i];
            flow[u][i] += f; //å·²ç”¨çš„æµé‡
            flow[i][u] -= f; //ç”¨äºä¿®æ­£ å¯èƒ½ä¼šä½¿ç”¨æµé‡ï¼ˆåå‘è¾¹ï¼‰
        } 
        maxflow += f;
    }
    return maxflow;
}

void mark_matching() {// æ ‡è®°åŒ¹é…å…³ç³»
    memset(left_used, 0, sizeof(left_used));
    memset(right_used, 0, sizeof(right_used));
    for (int i = 1; i <= n; i++) { // å·¦ä¾§ç‚¹
        for (int j = 1; j <= n; j++) { // å³ä¾§ç‚¹
            if (flow[i][n+j] > 0) { // å¦‚æœæœ‰æµé‡ï¼Œè¡¨ç¤ºåŒ¹é…
                left_used[i-1] = true;
                right_used[j-1] = true;
                break;
            }
        }
    }
}

void findPath(int u, vector<bool>& visited, vector<int>& path) {// æ‰¾åˆ°è·¯å¾„DFS
    path.push_back(u + 1); // 1-indexed
    visited[u] = true;
    for (int v : G[u]) {
        if (!visited[v] && flow[u+1][v+n+1] > 0) { // æ£€æŸ¥æ˜¯å¦æœ‰æµé‡
            findPath(v, visited, path);
            break;
        }
    }
}

int main() {
    cin >> n >> m;
    
// 1.åˆå§‹åŒ–
    s = 0;
    t = 2*n+1;
    memset(cap, 0, sizeof(cap));
    memset(flow, 0, sizeof(flow));
    
// 2.æ„å»ºç½‘ç»œæµå›¾
    for (int i = 1; i <= n; i++) {// æºç‚¹åˆ°å·¦ä¾§èŠ‚ç‚¹ï¼Œå®¹é‡ä¸º1
        cap[s][i] = 1;
    } 
    for (int i = 1; i <= n; i++) {// å³ä¾§èŠ‚ç‚¹åˆ°æ±‡ç‚¹ï¼Œå®¹é‡ä¸º1
        cap[n+i][t] = 1;// å³ä¾§èŠ‚ç‚¹ç¼–å·ä¸ºn+i
    }
    // è¯»å–åŸå›¾çš„è¾¹ï¼Œä»å·¦ä¾§åˆ°å³ä¾§èŠ‚ç‚¹ï¼Œå®¹é‡ä¸º1
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        --u; --v; // 0-indexed
        G[u].push_back(v);
        cap[u+1][v+n+1] = 1; // å³ä¾§èŠ‚ç‚¹ç¼–å·ä¸ºn+i
    }
    
// 3.æ±‚æœ€å¤§æµ
    int maxf = maxFlow();  
    int min_k = n - maxf;    // æœ€å°è·¯å¾„è¦†ç›–æ•° = èŠ‚ç‚¹æ•° - æœ€å¤§æµ
    
    cout << min_k << endl;
// 4.è·å¾—è·¯å¾„
    mark_matching();
    vector<bool> visited(n, false);
    for (int i = 0; i < n; i++) {
        if (!right_used[i] && !visited[i]) { // å³ä¾§æ²¡è¢«åŒ¹é…è¿›æ¥çš„ç‚¹æ˜¯è·¯å¾„å¼€å¤´
            vector<int> path;
            findPath(i, visited, path);
            if (!path.empty()) {
                cout << path.size();
                for (int x : path) cout << " " << x;
                cout << endl;
            }
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å­¤ç«‹çš„ç‚¹
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            cout << 1<<" "<< (i + 1) << endl;
        }
    }
    
    return 0;
}
